package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net"
	"net/http"
	"net/http/httputil"
	"net/url"
	"path"
	"strconv"
	"strings"
	"time"

	"github.com/docker/docker/api/types"
)

type connectItem struct {
	// proto holds the Docker Engine REST API protocol i.e. http.
	proto string
	// node holds the host of docker Node
	node string
	// port holds the port of the Docker Engine REST API service
	port int
	// container holds the Docker Container id which be generated by docker
	container string
	// version of the server to talk to.
	version string
	// shell holds the cmd interperer which can run in the container of the 'host' docker node
	shell string
	// 一个可执行实例 ID
	execId string
	// token 是否失效
	tokenEffect bool
}

func NewConnectItemWithOpts(ops ...func(*connectItem) error) (*connectItem, error) {

	c := &connectItem{
		proto:   "http",
		port:    2375,
		version: "v1.25",
		shell:   "bash",
	}

	for _, op := range ops {
		if err := op(c); err != nil {
			return nil, err
		}
	}

	return c, nil
}

func withVersion(version string) func(*connectItem) error {
	return func(c *connectItem) error {
		c.version = version
		return nil
	}
}

func withPort(port int) func(*connectItem) error {
	return func(c *connectItem) error {
		c.port = port
		return nil
	}
}

func withNode(node string) func(*connectItem) error {
	return func(c *connectItem) error {
		c.node = node
		return nil
	}
}

func withContainer(container string) func(*connectItem) error {
	return func(c *connectItem) error {
		c.container = container
		return nil
	}
}

func encodeData(data interface{}) (*bytes.Buffer, error) {
	params := bytes.NewBuffer(nil)
	if data != nil {
		if err := json.NewEncoder(params).Encode(data); err != nil {
			return nil, err
		}
	}
	return params, nil
}

// getAPIPath returns the versioned request path to call the api.
// It appends the query parameters to the path if they are not empty.
func (c *connectItem) getAPIPath(p string, query url.Values) string {
	var apiPath string
	if c.version != "" {
		v := strings.TrimPrefix(c.version, "v")
		apiPath = path.Join("/v"+v, p)
	} else {
		apiPath = p
	}
	host := c.node + ":" + strconv.Itoa(c.port)
	return (&url.URL{Scheme: c.proto, Host: host, Path: apiPath, RawQuery: query.Encode()}).String()
}

func (c *connectItem) exec() (string, error) {
	var response IDResponse

	req := ExecConfig{
		AttachStdin:  true,
		AttachStdout: true,
		AttachStderr: true,
		DetachKeys:   "ctrl-p,ctrl-q",
		Tty:          true,
		Cmd:          []string{c.shell},
		Privileged:   true,
	}

	reqJson, _ := encodeData(req)

	api := c.getAPIPath("containers/"+c.container+"/exec", url.Values{})
	resp, err := http.Post(api, "application/json", reqJson)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	err = json.NewDecoder(resp.Body).Decode(&response)

	fmt.Println(resp.StatusCode)
	if resp.StatusCode != 201 {
		return "", &ServerError{resp.StatusCode, response.Message}
	}

	return response.Id, nil
}

func (c *connectItem) start() (*HijackedResponse, error) {
	var params io.Reader
	opts := ExecStartCheck{
		Detach: false,
		Tty:    false,
	}
	encodeOpts, err := encodeData(opts)
	if err != nil {
		return nil, err
	}

	api := c.getAPIPath("exec/"+c.execId+"/start", url.Values{})
	req, err := http.NewRequest("POSt", api, encodeOpts)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Connection", "Upgrade")
	req.Header.Set("Upgrade", "tcp")

	conn, err := net.Dial(c.proto, c.node+":"+strconv.Itoa(c.port))
	if err != nil {
		return nil, err
	}

	// When we set up a TCP connection for hijack, there could be long periods
	// of inactivity (a long running command with no output) that in certain
	// network setups may cause ECONNTIMEOUT, leaving the client in an unknown
	// state. Setting TCP KeepAlive on the socket connection will prohibit
	// ECONNTIMEOUT unless the socket connection truly is broken
	if tcpConn, ok := conn.(*net.TCPConn); ok {
		tcpConn.SetKeepAlive(true)
		tcpConn.SetKeepAlivePeriod(30 * time.Second)
	}

	clientconn := httputil.NewClientConn(conn, nil)
	defer clientconn.Close()

	// Server hijacks the connection, error 'connection closed' expected
	resp, err := clientconn.Do(req)
	if err != httputil.ErrPersistEOF {
		if err != nil {
			return nil, err
		}
		if resp.StatusCode != http.StatusSwitchingProtocols {
			resp.Body.Close()
			return nil, fmt.Errorf("unable to upgrade to %s, received %d", proto, resp.StatusCode)
		}
	}

	c, br := clientconn.Hijack()
	if br.Buffered() > 0 {
		// If there is buffered content, wrap the connection.  We return an
		// object that implements CloseWrite iff the underlying connection
		// implements it.
		if _, ok := c.(types.CloseWriter); ok {
			c = &hijackedConnCloseWriter{&hijackedConn{c, br}}
		} else {
			c = &hijackedConn{c, br}
		}
	} else {
		br.Reset(nil)
	}

	return &HijackedResponse{conn, bufrw}, nil
}
